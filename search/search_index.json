{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welkom bij de cursus Microcontrollers","text":"<p>Deze website helpt je om microcontrollers te leren kennen, gebruiken en programmeren. In deze cursus bekijken we hoe dat kan met Arduino (C++) en met MicroPython. Kies een hoofdstuk in de inhoudstabel om te starten!</p> <p></p>"},{"location":"analoog_pwm/","title":"Analoge signalen en PWM","text":""},{"location":"analoog_pwm/#adc-analog-to-digital-converter","title":"ADC (Analog-to-Digital Converter)","text":"<p>Sommige pinnen kunnen een spanning meten (0\u20133.3 V).</p> <pre><code>// Arduino (C++) voorbeeld\nint potPin = A0;\nint waarde;\nvoid setup() {\n  Serial.begin(9600);\n}\nvoid loop() {\n  waarde = analogRead(potPin); // 0\u20131023\n  Serial.println(waarde);\n}\n</code></pre> <pre><code># MicroPython voorbeeld\nfrom machine import ADC, Pin\npot = ADC(Pin(26))\nwaarde = pot.read_u16() # 0\u201365535\nprint(waarde)\n</code></pre>"},{"location":"analoog_pwm/#pwm-pulse-width-modulation","title":"PWM (Pulse Width Modulation)","text":"<p>LED dimmen door het signaal snel aan/uit te schakelen.</p> <pre><code>// Arduino (C++) voorbeeld\nint ledPin = 9;\nvoid setup() {\n  pinMode(ledPin, OUTPUT);\n}\nvoid loop() {\n  analogWrite(ledPin, 128); // halve helderheid\n}\n</code></pre> <pre><code># MicroPython voorbeeld\nfrom machine import PWM, Pin\nled = PWM(Pin(25))\nled.duty_u16(32768) # halve helderheid\n</code></pre> <p></p>"},{"location":"bit_boolean/","title":"Bit en Boolean \u2013 de kleinste eenheid","text":""},{"location":"bit_boolean/#wat-is-een-bit","title":"Wat is een bit?","text":"<p>Een bit is de kleinste eenheid van informatie in een computer. Een bit kan maar 2 waarden hebben: alleen de waarde 0 of 1. </p> <p>Deze 2 waarden kunnen, afhankelijk van de context, anders genoemd worden, zo kan een 0 ook uit, laag of onwaar genoemd worden en een 1 op zijn beurt aan, hoog of waar.</p>"},{"location":"bit_boolean/#wat-is-een-variabele","title":"Wat is een variabele?","text":"<p>Een variabele is een naam voor een stukje geheugen in de computer waar je informatie in kunt opslaan.  </p> <p>Je kunt een variabele zien als een doosje met een label erop: je stopt er een waarde in, en je kunt die waarde later weer gebruiken of veranderen. Door het gebruik van variabelen, kunnen we krachtige en leesbare programma's maken.</p> <p>Een variabele heeft altijd een naam en een datatype.</p> <p>Met variabelen kun je informatie onthouden met de naam van de variabele als <code>label</code>. Bijvoorbeeld: <code>spanning = 230</code> waarbij we naar de waarde 230 kunnen refereren als spanning.</p>"},{"location":"bit_boolean/#wat-zijn-datatypes","title":"Wat zijn datatypes?","text":"<p>Een datatype bepaalt welk soort informatie een variabele kan opslaan in een programma.</p> <ul> <li>Voor een bit (waar/onwaar) gebruik je het datatype boolean.</li> <li>Andere datatypes, die we later nog uitgebreid gaan bespreken, bestaan uit meerdere bits. Bijvoorbeeld:</li> <li>integer: een geheel getal of een getal zonder decimalen (meestal 8, 16 of 32 bits)</li> <li>float: een  kommagetal of getal met decimalen</li> <li>string: een stukje tekst</li> </ul> <p>Hoe meer bits een datatype heeft, hoe meer verschillende waarden je ermee kunt opslaan.  </p> <p>Een boolean kan maar twee waarden hebben (0 of 1), maar een unsigned integer (geheel getal zonder teken) van 8 bits kan bijvoorbeeld waarden van 0 tot 255 bevatten.</p> <p>Het juiste datatype kiezen is belangrijk om je programma goed te laten werken!</p>"},{"location":"bit_boolean/#boolean-in-code","title":"Boolean in code","text":"<p>In programmeertalen gebruik je het datatype boolean om met waar/onwaar te werken.</p>"},{"location":"bit_boolean/#in-c","title":"In C++","text":"<p>In C++ moet je het datatype van een variabele altijd expliciet vermelden. </p> <p>Bij een boolean betekent 0 hetzelfde als <code>false</code> en 1 hetzelfde als <code>true</code>.</p> <pre><code>// cpp\nbool ledAan = true;   // LED aan\nbool knopIngedrukt = false; // Knop niet ingedrukt\n</code></pre> <p>In het bovenstaande voorbeeld, hebben we 2 variabelen gemaakt: <code>ledAan</code> en <code>knopIngedrukt</code>. Ze zijn van het type bool (boolean) en hebben de respectievelijke waarde <code>true</code> en <code>false</code>.</p>"},{"location":"bit_boolean/#in-micropython","title":"In MicroPython","text":"<p>In MicroPython hoef je het datatype van een variabele niet expliciet te vermelden. Python kiest zelf het type op basis van de waarde.</p> <p>Toch is het heel belangrijk om zelf goed te weten welk type je gebruikt. Ook hier geldt: 0 is <code>False</code> en 1 is <code>True</code>. Let op: in Python schrijf je True en False altijd met een hoofdletter!</p> <pre><code># MicroPython\nled_aan = True      # LED aan\nknop_ingedrukt = False  # Knop niet ingedrukt\n</code></pre> <p>In het bovenstaande voorbeeld, hebben we 2 variabelen gemaakt: <code>led_aan</code> en <code>knop_ingedrukt</code>. We kunnen enkel aan de waarde zien dat ze van het type boolean  zijn: ze hebben namelijk de respectievelijke waarde <code>True</code> en <code>False</code>.</p>"},{"location":"bit_boolean/#waar-kom-je-bits-en-booleans-tegen","title":"Waar kom je bits en booleans tegen?","text":"<ul> <li>Bij het aansturen van uitgangen (LED aan/uit)</li> <li>Bij het uitlezen van ingangen (knop ingedrukt of niet)</li> <li>In logische beslissingen (if-statements)</li> </ul> <p>Een boolean is dus een handige manier om met ja/nee-vragen in je programma te werken!</p>"},{"location":"bit_boolean/#extra-naamgeving-van-variabelen","title":"Extra: Naamgeving van variabelen","text":"<p>Probeer altijd een naam te kiezen die duidelijk maakt wat de variabele voorstelt.</p> <p>Bij het kiezen van een variabelenaam is het handig om een duidelijke conventie te volgen. Dit maakt je code beter leesbaar en begrijpelijk voor anderen (en jezelf!).</p> <ul> <li> <p>In C++ gebruiken programmeurs vaak de camelCase-notatie.   Hierbij begint de naam met een kleine letter en elk nieuw woord krijgt een hoofdletter.   Bijvoorbeeld: <code>ledAan</code>, <code>knopIngedrukt</code></p> </li> <li> <p>In MicroPython (en Python in het algemeen) wordt meestal de snake_case-notatie gebruikt.   Hierbij worden woorden gescheiden door een underscore (_), alles in kleine letters.   Bijvoorbeeld: <code>led_aan</code>, <code>knop_ingedrukt</code></p> </li> </ul> <p>Het is niet verplicht, maar het volgen van deze conventies maakt je code overzichtelijker!  Het volgen van conventies maakt je code overzichtelijker en wordt vaak gewaardeerd door docenten en programmeurs.</p>"},{"location":"componenten/","title":"Elektronische componenten","text":"<p>Hier vind je uitleg over de belangrijkste basiscomponenten die we nodig hebben bij het gebruik van microcontrollers of om de werking te beschrijven.</p>"},{"location":"componenten/#dc-spanningsbron","title":"DC Spanningsbron","text":"<p>Symbool: </p> <p>De spanningsbron is de voeding voor je microcontroller. Dit kan een batterij zijn, een adapter of de USB-poort van je computer.</p>"},{"location":"componenten/#diode","title":"Diode","text":"<p>Symbool: </p> <p>Een diode laat stroom maar in \u00e9\u00e9n richting door. Zoals het in dit symbool staat, kan de stroom van boven naar onder stromen maar niet omgekeerd.</p>"},{"location":"componenten/#led-light-emitting-diode","title":"LED (Light Emitting Diode)","text":"<p>Symbool: </p> <p>Een LED is een speciale diode, ze geeft licht als er voldoende stroom doorheen gaat. Gebruik altijd een serieweerstand om ervoor te zorgen dat er niet te veel stroom doorheen vloeit! Dan kan de LED of de uitgang van de microcontroller immers kapot gaan.</p>"},{"location":"componenten/#weerstand","title":"Weerstand","text":"<p>Symbool: </p> <p>Een weerstand beperkt de stroom in een circuit. Dit hebben we bijvoorbeeld nodig bij het aansluiten van een LED!</p>"},{"location":"componenten/#zekering-fuse","title":"Zekering (Fuse)","text":"<p>Symbool: </p> <p>Een zekering beschermt tegen te hoge stroom. Wanneer de stroom te groot wordt, zal de zekering gecontroleerd doorbranden. Let op: een zekering is geen weerstand, vele leerlingen tekenen een weerstand met het symbool van een zekering maar dat is helemaal verkeerd!</p>"},{"location":"componenten/#schakelaar-spdt","title":"Schakelaar (SPDT)","text":"<ul> <li>Afbeelding: </li> <li>Symbool: </li> </ul> <p>Met een SPDT (Single Pole Dual Throw) schakelaar of tuimelschakelaar, kan je kiezen hoe \"middelste\" contact verbonden wordt. In het model op de foto, kan je zorgen dat het met geen van beiden contact maakt maar dit kan meestal niet. Het is ofwel verbonden met het ene, ofwel met het andere en daar zit slechts een zeer korte \"dode tijd\" tussen. Deze schakelaar komt later terug bij output.</p>"},{"location":"componenten/#microcontroller","title":"Microcontroller","text":"<p>Symbool: </p> <p>Dit is het symbool van de ATmega328-p. Deze microcontroller wordt ondermeer gebruikt op de Arduino UNO R3.</p> <p>Zoals je ziet, is het symbool eerder simpel, een rechthoek met veel aansluitingen. Dit is vaak het geval bij complexere componenten. Je zal merken dat de grond (GND of 0V) vaak onderaan staat en de voedingsspanning (VCC) in de regel bovenaan. Ook zullen inputs vaak links staan en outputs rechts. Hier komen we later nog terug, wanneer we beter weten wat in- en outputs zijn. De signaalnamen staan in de rechthoek terwijl de pinnummers buiten de rechthoek, naast de pinnen genoteerd staan.</p>"},{"location":"componenten/#microcontroller-bord","title":"Microcontroller bord","text":"<p>Symbool: </p> <p>Dit is het symbool van het microcontroller bord Arduino UNO R3. Zoals je kan zien, lijkt het heel erg op een symbool van de microcontroller maar het is niet helemaal hetzelfde. Een microcontroller is een component terwijl er op een microcontroller bord meerdere componenten staan, waaronder de microcontroller zelf. Van deze extra componenten maken we abstractie (we tekenen ze niet). Enkel de pinnen waarmee we het bord verbinden, worden in het symbool getekend.</p>"},{"location":"componenten/#schemas","title":"Schema's","text":"<p>We gebruiken deze symbolen om schema's te tekenen, zodat we duidelijk kunnen maken hoe de componenten aangesloten worden. Je vind heel veel informatie over microcontroller borden zoals de Arduino. Soms vind je een tekening zoals hieronder die duidelijk maken hoe een Arduino aan een ander bord of component aangesloten moet worden.</p> <p>Tekening: </p> <p>Deze tekening komt van een website (bron: instructables.com).</p> <p>Er wordt getoond hoe een BMP280 module, die temperatuur en luchtdruk kan meten, via een breadbord aangesloten wordt aan een Arduino R3. Deze tekening geeft een beschrijving van de aansluitingen maar het is geen schema. De verschillende onderdelen worden grafisch voorgesteld en niet met symbolen. Dit werkt meestal goed om kleine, gemakkelijke schakelingen na te bouwen maar het werkt niet zo goed voor grotere of complexere circuits of om te begrijpen hoe de schakeling werkt. Als we hetzelfde circuit schematisch willen voorstellen, kan het er bijvoorbeeld zo uit zien:</p> <p>Schema: </p> <p>In tegenstelling met de tekening, zien we hier duidelijk dat SDA signaal van de microcontroller met SDI van de sensor verbonden wordt en het SCL signaal van de microcontroller met SCK van de sensor. Op dit moment weet je waarschijnlijk nog niet wat dat wil zeggen of waarom dat nuttig is maar wanneer je binnenkort meer weet over seri\u00eble communicatie, zal je het circuit veel beter begrijpen. Voorlopig moet je weten dat een tekening vooral bedoeld is om een circuit te kunnen nabouwen en een schema om het circuit te kunnen begrijpen en nabouwen.</p>"},{"location":"datatypes/","title":"Meer datatypes","text":""},{"location":"datatypes/#van-1-bit-naar-8-bits","title":"Van 1 bit naar 8 bits","text":"<p>We hebben al gezien dat 1 bit maar 2 waarden kan hebben: 0 of 1. Maar wat als we meer verschillende waarden of grotere getallen willen opslaan? Dan combineren we meerdere bits!</p>"},{"location":"datatypes/#met-8-bits-kun-je-256-verschillende-waarden-maken","title":"Met 8 bits kun je 256 verschillende waarden maken","text":"<p>Stel je voor dat je 8 lampjes naast elkaar hebt. Elk lampje kan aan (1) of uit (0) zijn. Door verschillende combinaties te maken, kun je 256 verschillende patronen cre\u00ebren!</p> <p>Voorbeelden: - <code>00000000</code> = 0 - <code>00000001</code> = 1 - <code>00000010</code> = 2 - <code>00000011</code> = 3 - <code>11111111</code> = 255</p> <p>Met 8 bits kun je dus getallen van 0 tot 255 voorstellen!</p> Bit 7 Bit 6 Bit 5 Bit 4 Bit 3 Bit 2 Bit 1 Bit 0 2\u2077 2\u2076 2\u2075 2\u2074 2\u00b3 2\u00b2 2\u00b9 2\u2070 128 64 32 16 8 4 2 1 <p>Bijvoorbeeld: het getal 42 zou er zo uitzien:</p> <p>42 = 32 + 8 + 2 = <code>00101010</code></p>"},{"location":"datatypes/#waarom-is-dit-handig","title":"Waarom is dit handig?","text":"<ul> <li>Tellen: In plaats van alleen 0 en 1, kun je nu tot 255 tellen.</li> <li>Sensoren: Een temperatuursensor kan waarden van 0\u00b0C tot 255\u00b0C meten.</li> <li>Kleuren: Elk van de kleuren rood, groen en blauw gebruikt 8 bits (0-255).</li> </ul>"},{"location":"datatypes/#datatypes-in-c-arduino","title":"Datatypes in C++ (Arduino)","text":"<p>In C++ moet je altijd aangeven welk datatype je gebruikt. Dit helpt de computer om te weten hoeveel geheugen hij moet reserveren.</p>"},{"location":"datatypes/#unsigned-int","title":"unsigned int","text":"<p>Geheel getal zonder minteken</p> <p><pre><code>unsigned int teller = 0;  // Kan waarden van 0 tot 65535 bevatten\n</code></pre> Gebruik: Voor getallen die nooit negatief worden, zoals:</p> <ul> <li>Aantal keer dat je op een knop drukt</li> <li>Sensor waarden (0-1023 van een potmeter)</li> <li>Tijd in milliseconden</li> </ul>"},{"location":"datatypes/#signed-int","title":"(signed) int","text":"<p>Geheel getal met minteken <pre><code>int temperatuur = -5;  // Kan waarden van -32768 tot +32767 bevatten\n</code></pre></p> <p>Gebruik: Voor getallen die ook negatief kunnen zijn, zoals:</p> <ul> <li>Temperatuur (kan onder 0\u00b0C zijn)</li> <li>Positie (links/rechts van een startpunt)</li> <li>Verschil tussen twee metingen</li> </ul>"},{"location":"datatypes/#char","title":"char","text":"<p>Karakter of klein getal <pre><code>char letter = 'A';     // Voor letters\nchar kleinGetal = 42;  // Voor getallen van -128 tot +127\n</code></pre> Gebruik:</p> <ul> <li>Voor enkele letters of tekens</li> <li>Voor heel kleine getallen (om geheugen te besparen)</li> </ul>"},{"location":"datatypes/#float","title":"float","text":"<p>Kommagetal (decimaal getal)</p> <p><pre><code>float temperatuur = 23.5;     // Kan decimalen hebben\nfloat spanning = 3.14159;     // Pi met decimalen\n</code></pre> Wat is een float?</p> <p>Een float is een getal met een komma (eigenlijk punt in code). Het kan dus ook gebroken getallen voorstellen.</p> <p>Voorbeelden:</p> <ul> <li>Temperatuur: <code>20.3\u00b0C</code> in plaats van alleen <code>20\u00b0C</code></li> <li>Spanning: <code>3.7V</code> in plaats van alleen <code>3V</code></li> <li>Afstand: <code>12.45 meter</code></li> </ul> <p>Gebruik: Voor metingen die preciezer moeten zijn dan hele getallen:</p> <ul> <li>Temperatuursensoren (23.4\u00b0C)</li> <li>Spanningsmetingen (3.7V)</li> <li>Afstandsmetingen (15.6 cm)</li> <li>Berekeningen (gemiddelden, procenten)</li> </ul> <p>Let op: Floats zijn minder nauwkeurig dan je denkt! Soms krijg je <code>3.9999999</code> in plaats van <code>4.0</code>. Dit komt omdat ze binair opgeslagen worden.</p>"},{"location":"datatypes/#datatypes-in-micropython","title":"Datatypes in MicroPython","text":"<p>In MicroPython hoef je het datatype niet expliciet te vermelden. Python kiest automatisch het juiste type op basis van de waarde die je opslaat.</p> <p>Maar: Het is nog steeds belangrijk dat jij weet welk datatype je gebruikt!</p>"},{"location":"datatypes/#gehele-getallen-integers","title":"Gehele getallen (integers)","text":"<p><pre><code>teller = 0        # Python kiest automatisch 'int'\ntemperatuur = -5  # Ook een 'int', maar kan negatief zijn\n</code></pre> Python is slim: Het maakt automatisch genoeg ruimte voor je getal, ook als het heel groot wordt!</p>"},{"location":"datatypes/#karakters-en-tekst-strings","title":"Karakters en tekst (strings)","text":"<pre><code>letter = 'A'           # E\u00e9n karakter\ntekst = \"Hallo wereld\" # Hele zin\n</code></pre>"},{"location":"datatypes/#kommagetallen-floats","title":"Kommagetallen (floats)","text":"<p><pre><code>temperatuur = 23.5      # Python herkent automatisch dat dit een float is\nspanning = 3.14159      # Ook een float\n</code></pre> Python is nog slimmer: Het herkent automatisch of je getal een integer (geheel getal) of float (kommagetal) is! <pre><code>geheel_getal = 25        # Dit is een int\nkomma_getal = 25.0       # Dit is een float (let op de .0)\n</code></pre></p>"},{"location":"datatypes/#samenvatting","title":"Samenvatting","text":""},{"location":"datatypes/#c-arduino","title":"C++ (Arduino):","text":"<ul> <li>Je moet het datatype aangeven</li> <li>Beperkte ruimte per datatype</li> <li>Sneller en gebruikt minder geheugen</li> </ul>"},{"location":"datatypes/#micropython","title":"MicroPython:","text":"<ul> <li>Python kiest automatisch het datatype</li> <li>Onbeperkte ruimte (binnen grenzen van de microcontroller)</li> <li>Langzamer maar gemakkelijker te programmeren</li> </ul> <p>Tip: Ook in Python is het handig om te weten welk type je gebruikt, vooral bij sensoren die bepaalde waardenbereiken hebben!</p>"},{"location":"gpio/","title":"GPIO \u2013 General Purpose Input/Output","text":"<p>GPIO staat voor General Purpose Input/Output. Dit zijn de pinnen op een microcontroller die je kunt instellen om ze te gebruiken als input (iets meten) of output (iets aansturen).</p> <ul> <li>GPIO als output: bijvoorbeeld een LED aan/uit zetten.</li> <li>GPIO als input: bijvoorbeeld een knop uitlezen.</li> </ul> <p>GPIO is de brug tussen de concepten input/output en de echte hardware. We kunnen een vereenvoudigde GPIO schematisch zo voorstellen:</p> <p></p> <p>Dit is de standaard configuratie van een GPIO. Tenzij we de configuratie van een pin veranderen, is de GPIO zoals hierboven geconfigureerd. Alle \"inwendige schakelaars\" zijn open dus de GPIO gedraagt zich als een input.</p>"},{"location":"gpio/#gpio-in-input-mode","title":"GPIO in \"input\" mode","text":"<p>In C++ kunnen we de status van een ingang lezen door middel van het pin nummer (<code>digitalRead(&lt;pin_nummer&gt;)</code>). Als een bepaalde GPIO altijd als input gebruikt gaat worden, moet je dit dus niet specifiek instellen. Maar als tijdens je programma de GPIO in een andere mode gebruikt hebt en je wil hem terug als ingang instellen, kan dat op deze manier:</p> <p><pre><code>// cpp\npinMode(14, INPUT);  // zet pin 14 in INPUT mode\n</code></pre> In MicroPython gaat het een beetje anders. In het deel over de output en input, zagen we dat we moeten aangeven waarvoor een pin gebruikt wordt en dat je die dan pas kunt gebruiken. Hier gaan we eindelijk zien hoe dat moet gebeuren.</p> <p>Een verschil tussen Arduino en MicroPython is dat bij Arduino de bibliotheken die nodig zijn om een GPIO te gebruiken, standaart toegangkelijk zijn. In MicroPython moet je de bibliotheek bovenaan je code aanroepen. Dat gebeurt zo: <pre><code># MicroPython\nfrom machine import Pin\n</code></pre> Als dit bovenaan in de code staat, kan je in je verdere code GPIO's configureren (is in de gewenste mode zetten) en gebruiken. Het configureren als input gaat dan zo:</p> <p><pre><code># MicroPython\n\n# Pin 14 als gewone input\nbutton = Pin(14, Pin.IN)\n</code></pre> Eigenlijk lijkt in MicroPython een GPIO op een object dat eigenschappen heeft. We gaan de details hiervan later nog bekijken maar het komt er voorlopig op neer dat je de GPIO een betekenisvolle naam geeft. </p> <pre><code># MicroPython\n\n# De input waarde inlezen\nwaarde = button.value()\n</code></pre>"},{"location":"gpio/#gpio-in-input-pull-up-mode","title":"GPIO in \"input-pull-up\" mode","text":"<p>We zetten onze vereenvoudigde GPIO in input-pull-up mode door schakelaar Q4 te sluiten:</p> <p></p> <p>In C++ stellen we de GPIO opnieuw met pinMode in:</p> <p><pre><code>// cpp\npinMode(14, INPUT_PULLUP);  // zet pin 14 in INPUT-PULLUP mode\n</code></pre> Ook in MicroPython gebeurt het op een gelijkaardige manier, alleen komt er nu een argument (tussen de haakjes) bij. Het is alsof we zeggen dat de GPIO een input is en dat de pull-up weerstand moet aangezet worden. <pre><code># MicroPython\n\n# Pin 14 als input met pull-up weerstand \nbutton = Pin(14, Pin.IN, Pin.PULL_UP)  \n</code></pre></p>"},{"location":"gpio/#gpio-in-input-pull-down-mode","title":"GPIO in \"input-pull-down\" mode","text":"<p>Niet alle microcontrollers hebben deze mogelijkheid. Bijvoorbeeld de veelgebruikte Arduino UNO r3 heeft geen interne pull-down weerstanden. Daarmee is deze optie niet beschikbaar. In de praktijk worden pull-up weerstanden veel vaker gebruikt dan pull-down weerstanden, dus het is vaak geen probleem. Voor de microcontrollers die het wel hebben, zoals de ESP-32, beschrijven we deze pull-down mode.</p> <p>We zetten onze vereenvoudigde GPIO in input-pull-down mode door schakelaar Q3 te sluiten:</p> <p></p> <p>In C++ stellen we de GPIO opnieuw met pinMode in:</p> <p><pre><code>// cpp\npinMode(14, INPUT_PULLDOWN);  // zet pin 14 in INPUT-PULLDOWN mode\n</code></pre> Ook in MicroPython gebeurt het op een gelijkaardige manier als bij de pull-up mode.</p> <pre><code># MicroPython\n\n# Pin 14 als input met pull-down weerstand  \nbutton = Pin(14, Pin.IN, Pin.PULL_DOWN)\n</code></pre>"},{"location":"gpio/#gpio-in-output-mode","title":"GPIO in \"output\" mode","text":"<p>Wanneer we de GPIO in output mode zetten, wordt de pin verbonden met GND of VCC. Hoe we dat doen, hadden we al in het hoofdstuk van de output gezien. Schematisch ziet het er eigenlijk wel iets anders uit dan met de \"interne SPDT\" schakelaar, al is de werking compleet hetzelfde. De 2 mogelijkheden in output mode zijn deze:</p> <p>OUTPUT-mode, LAAG</p> <p></p> <p>Dit wordt gedaan door alleen de inwendige schakelaar Q1 te sluiten. De GPIO pin wordt intern met GND verbonden.</p> <p>OUTPUT-mode, HOOG</p> <p></p> <p>Dit wordt gedaan door alleen de inwendige schakelaar Q2 te sluiten. De GPIO pin wordt intern met VCC verbonden.</p> <p>Een GPIO in C++ in output-mode te zetten, doen we zo:</p> <p><pre><code>// cpp\npinMode(12, OUTPUT);  // zet pin 12 in OUTPUT mode\n</code></pre> In MicroPython doen we het zo:</p>"},{"location":"gpio/#micropython-from-machine-import-pin-pin-12-als-output-led-pin12-pinout","title":"<pre><code># MicroPython\nfrom machine import Pin\n\n# Pin 12 als output\nled = Pin(12, Pin.OUT)\n</code></pre>","text":""},{"location":"gpio/#samenvatting-gpio-configureren","title":"Samenvatting: GPIO configureren","text":""},{"location":"gpio/#c-arduino","title":"C++ (Arduino)","text":"Mode Instructie Gebruik Input <code>pinMode(pin, INPUT);</code> Gewone ingang, externe pull-up/down nodig Input Pull-up <code>pinMode(pin, INPUT_PULLUP);</code> Ingang met interne pull-up weerstand Input Pull-down <code>pinMode(pin, INPUT_PULLDOWN);</code> Ingang met interne pull-down weerstand* Output <code>pinMode(pin, OUTPUT);</code> Uitgang (hoog/laag) <p>*Niet beschikbaar op alle microcontrollers (bv. Arduino UNO r3)</p> <p>Waarden lezen/schrijven: <pre><code>// Lezen\nbool waarde = digitalRead(pin);\n\n// Schrijven  \ndigitalWrite(pin, HIGH);  // of LOW\n</code></pre></p>"},{"location":"gpio/#micropython","title":"MicroPython","text":"Mode Instructie Gebruik Input <code>pin = Pin(nummer, Pin.IN)</code> Gewone ingang, externe pull-up/down nodig Input Pull-up <code>pin = Pin(nummer, Pin.IN, Pin.PULL_UP)</code> Ingang met interne pull-up weerstand Input Pull-down <code>pin = Pin(nummer, Pin.IN, Pin.PULL_DOWN)</code> Ingang met interne pull-down weerstand Output <code>pin = Pin(nummer, Pin.OUT)</code> Uitgang (hoog/laag) <p>Vergeet niet de bibliotheek te importeren: <pre><code>from machine import Pin\n</code></pre> Waarden lezen/schrijven: <pre><code># Lezen\nwaarde = pin.value()\n\n# Schrijven\npin.value(1)    # of 0, True, False\n</code></pre></p>"},{"location":"inhoud/","title":"Inhoudstabel","text":"<ol> <li>Introductie</li> <li>Componenten</li> <li>Bit en Boolean \u2013 de kleinste eenheid</li> <li>Output \u2013 dingen aansturen</li> <li>Input \u2013 dingen meten</li> <li>GPIO \u2013 Input/Output in de praktijk</li> <li>Meer datatypes</li> <li>Analoge signalen en PWM</li> <li>Samenspel en toepassingen</li> <li>Vooruitblik</li> </ol>"},{"location":"input/","title":"Input \u2013 Dingen meten","text":"<p>Input betekent dat de microcontroller informatie ontvangt uit de buitenwereld. Dit kan bijvoorbeeld een knop, een sensor of een schakelaar zijn.</p>"},{"location":"input/#het-concept-van-digitale-input","title":"Het concept van digitale input","text":"<p>Stel je voor dat je een heel eenvoudige voltmeter hebt die maar twee waarden kan weergeven:</p> <ul> <li>True (waar) = er staat spanning op de ingang</li> <li>False (onwaar) = er staat geen spanning op de ingang</li> </ul> <p>Deze voltmeter kan dus alleen maar ja of nee antwoorden op de vraag: \"Is er spanning?\"</p> <p>Zo werkt digitale input ook: de microcontroller meet of er spanning staat op een pin en geeft als antwoord een boolean terug.</p>"},{"location":"input/#voorbeelden-van-digitale-input","title":"Voorbeelden van digitale input","text":"<ol> <li> <p>Drukknop indrukken: </p> <ul> <li>Knop ingedrukt = True (spanning aanwezig)</li> <li>Knop niet ingedrukt = False (geen spanning)</li> </ul> </li> <li> <p>Schakelaar:</p> <ul> <li>Schakelaar aan = True </li> <li>Schakelaar uit = False</li> </ul> </li> <li> <p>Eenvoudige sensor:</p> <ul> <li>Object gedetecteerd = True</li> <li>Geen object = False</li> </ul> </li> </ol>"},{"location":"input/#schema-voorstelling","title":"Schema-voorstelling","text":"<p>Net zoals bij output kunnen we dit voorstellen in een schema:</p> <p></p> <p>De microcontroller werkt als een digitale voltmeter: hij meet alleen of er wel of geen spanning staat, niet hoeveel spanning er precies is.</p>"},{"location":"input/#input-lezen-in-code","title":"Input lezen in code","text":""},{"location":"input/#in-c-arduino","title":"In C++ (Arduino)","text":"<p>In C++ lees je een digitale ingang uit met de functie <code>digitalRead()</code>:</p> <p><pre><code>// cpp\nbool knopStatus = digitalRead(4);  // Lees pin 4 uit\n</code></pre> Je krijgt dan <code>HIGH</code> (of <code>true</code>) terug als er spanning op de pin staat, of <code>LOW</code> (of <code>false</code>) als er geen spanning staat.</p> <p>Opmerking, in het bovenstaande voorbeeld wordt er een variabele knopStatus aangemaakt om de waarde van digitalRead in op te vangen. Wanneer die variabele reeds bestaat in het programma, is het datatype <code>bool</code> in het begin van de lijn niet meer nodig.</p>"},{"location":"input/#in-micropython","title":"In MicroPython","text":"<p>In MicroPython ziet het er opnieuw net iets anders uit. Daar moeten we eerst aangeven dat knop aan pin 4 is aangesloten. Hoe dat moet, volgt later. Je leest een digitale ingang uit met de methode <code>.value()</code>:</p> <p><pre><code># MicroPython\nknop_status = knop.value()  # Lees de knop uit\n</code></pre> Je krijgt dan <code>1</code> (of <code>True</code>) terug als er spanning op de pin staat, of <code>0</code> (of <code>False</code>) als er geen spanning staat.</p>"},{"location":"input/#schmitt-trigger-waarom-niet-gewoon-bij-25v-omschakelen","title":"Schmitt Trigger - waarom niet gewoon bij 2,5V omschakelen?","text":"<p>Je zou denken: \"Waarom schakelt de microcontroller niet gewoon om bij 2,5V (de helft van 5V)?\" Het probleem is dat spanningen kunnen trillen of ruis kunnen hebben. Als de spanning heel langzaam stijgt of daalt rond 2,5V, zou de uitgang heel vaak kunnen omschakelen tussen 0 en 1.</p> <p>Oplossing: De Schmitt Trigger Een microcontroller gebruikt daarom een Schmitt Trigger. Dit betekent: - Bij stijgende spanning schakelt hij om van 0 naar 1 bij bijvoorbeeld 3,0V - Bij dalende spanning schakelt hij om van 1 naar 0 bij bijvoorbeeld 2,0V</p> <p></p> <p>Deze verschillende drempelwaardes maken het systeem stabieler en voorkomen ongewenste schakelingen door ruis.</p> <p>Dit heet hysterese (of hysteresis in het Engels) - een slim trucje om storing te voorkomen!</p>"},{"location":"input/#drukknopschakelaars","title":"Drukknopschakelaars","text":"<p>In de bovenstaande uitleg sloten we een wisselschakelaar (of SPDT schakelaar) aan op de ingang van de microcontroller. Ondanks dat dit perfect werkt, gaan we dit in de praktijk niet veel zien. De meeste drukknopschakelaars hebben slechts 2 contacten en deze zijn open wanneer er niet op gedrukt wordt en gesloten wanneer er op gedrukt wordt. Om dit type schakelaar aan te sluiten, moeten we het circuit een beetje uitbreiden. Dit is dan ook de reden waarom we de uitleg van de input aanvankelijk met een ander type schakelaar hebben gedaan, zodat het circuit eenvoudiger en dus begrijpbaarder is.</p> <p>Wanneer we de wisselschakelaar vervangen door een normaal-open (of SPST) schakelaar, ziet het schema er bijvoorbeeld zo uit:</p> <p></p> <p>De schakeling zoals hierboven afgebeeld, zal niet werken; de interne voltmeter kan geen verschil detecteren tussen wanneer de schakelaar ingedrukt (gesloten) is en wanneer hij niet ingedrukt (open) is. Om het circuit wel te laten werken, voegen we een weerstand toe die de spanning \"naar boven\" trekt wanneer de schakelaar open is. Dit noemen we een pull-up weerstand.</p> <p></p> <p>Let op: de spanning is hoog wanneer de drukknopschakelaar niet ingedrukt is en laag wanneer hij ingedrukt is. Dit is dan ook een actief laag signaal.</p> <p>We kunnen de drukknopschakelaar en de weerstand omdraaien om er een actief hoog signaal van te maken:</p> <p></p>"},{"location":"input/#weerstandswaarde","title":"Weerstandswaarde","text":"<p>De waarde van de pull-up of pull-down weerstand is niet zo kritisch. Meestal wordt een weerstand met een waarde tussen 10k\u03a9 en 100k\u03a9 gebruikt. Wanneer de waarde lager dan 10k\u03a9 is, loopt er meer stroom dan nodig door de weerstand wanneer de drukknopschakelaar ingedrukt wordt. Wanneer de waarde te hoog is, meer dan 100k\u03a9, is de spanningsverandering mogelijk te klein om opgemerkt te worden door de ingang.</p>"},{"location":"input/#interne-pull-up-en-pull-down","title":"Interne pull-up en pull-down","text":"<p>De meeste microcontrollers hebben de mogelijkheid om gebruik te maken van een interne pull-up weerstand. Dit wil zeggen dat de pull-up weerstand in de microcontroller zit en dat er geen externe weerstand toegevoegd moet worden. Het schema ziet er dan zo uit:</p> <p></p> <p>Uitwendig moet de drukknopschakelaar aangesloten worden tussen de ground en de input pin van de microcontroller. </p> <p>Bij sommige microcontrollers is het ook mogelijk om een interne pull-down te gebruiken. Dat ziet er dan zo uit:</p> <p></p> <p>De drukknopschakelaar wordt nu aangesloten tussen de VCC en de input pin.</p> <p>De Arduino Uno R3 beschikt niet over een interne pull-down weerstand!</p> <p>Lees verder op de pagina 'GPIO' hoe je deze instellingen met een microcontroller doet.</p>"},{"location":"introductie/","title":"Introductie","text":""},{"location":"introductie/#hoofdstuk-1-wat-is-een-microcontroller","title":"Hoofdstuk 1 \u2013 Wat is een microcontroller?","text":""},{"location":"introductie/#11-wat-is-een-microcontroller","title":"1.1 Wat is een microcontroller?","text":"<p>Een microcontroller is een kleine computer op een chip. Hij kan drie dingen:</p> <ul> <li>Meten (via ingangen of sensoren)</li> <li>Denken (programma uitvoeren)</li> <li>Sturen (via uitgangen, bijvoorbeeld een LED of motor aanzetten)</li> </ul> <p>Voorbeelden:</p> <ul> <li>Raspberry Pi Pico</li> <li>Arduino Uno</li> </ul> <p></p>"},{"location":"introductie/#12-verschil-met-een-computer","title":"1.2 Verschil met een computer","text":"<p>Een laptop kan veel dingen tegelijk doen (internet, filmpjes, spelletjes). Een microcontroller doet meestal \u00e9\u00e9n taak, maar kan dat heel betrouwbaar en snel. Bijvoorbeeld: een wasmachine besturen, lampen automatisch schakelen of een robot laten bewegen.</p>"},{"location":"introductie/#13-programmeren","title":"1.3 Programmeren","text":"<p>Er zijn vele verschillende mogelijkheden om microtrollers te programmeren. Wij gaan ons beperken tot C++ en python.</p> <p>Alle Arduino borden zijn te programmeren in C++. Sommige (de meer krachtige) kunnen ook in MicroPython geprogrammeerd worden. Dit is eigenlijk een light versie van python met enkele bibliotheken die speciaal bedoeld zijn voor microcontrollers. Doorheen de verdere cursus gaan we steeds zowel de code in C++ als MicroPython bespreken. Dit gebeurt in \"code blokken\" zoals hier:</p> <pre><code>// cpp\n\n// Hier staat commentaar in C ++\n</code></pre> <pre><code># MicroPython\n\n# Hier staat commentaar in python\n</code></pre>"},{"location":"introductie/#14-veilig-werken-met-elektronica","title":"1.4 Veilig werken met elektronica","text":"<p>Microcontrollers werken meestal op 3.3V of 5V. Spanningen tot en met 24V zijn veilig voor mensen.</p> <p>Dit wil niet zeggen dat mensen veilig zijn voor microcontrollers. Het vermogen dat een microcontroller bord kan leveren is beperkt. Sluit nooit rechtstreeks een grote motor of lamp aan. Dit kan leiden tot te hoge stromen waardoor de microcontroller of het bord kapot kan gaan.</p> <p>Zoals in het hoofdstuk over componenten al vermeld werd: altijd een weerstand in serie zetten met een LED, anders kan er iets kapot gaan.</p> <p></p>"},{"location":"output/","title":"Output \u2013 Dingen aansturen","text":"<p>Output betekent dat de microcontroller iets aanstuurt of laat gebeuren. Dit kan bijvoorbeeld een LED, een motor, een buzzer of een display zijn.</p> <p>We kunnen dit voorstellen door te denken aan een SPDT-schakelaar in de microcontroller die het signaal verbindt met VCC (de voedingsspanning, meestal 5V of 3,3V) of met GND (grond, \u2018ground\u2019 of 0V).</p> <p>Schema: </p> <p>In het bovenstaande voorbeeld zien we dat pin 3 aangesloten is aan een LED met een serie weerstand. De microcontroller (of het microcontroller bord) is ook aangesloten aan een spanningsbron of voeding. De uitgang op pin 3 kan verbonden worden met ofwel VCC ofwel GND. Zoals in het schema te zien is, is de uitgang op dit moment verbonden met VCC, waardoor er stroom door de LED en serieweerstand loopt en de LED licht geeft.</p> <p>We bekijken nu hoe we in C++, de taal die Arduino gebruikt, de uitgang met VCC verbinden om de LED te laten branden:</p> <p><pre><code>// cpp\ndigitalWrite(3, true); // Pin 3 hoog, LED aan\n</code></pre> In MicroPython ziet het er net iets anders uit. Daar moeten we eerst aangeven dat led aan pin 3 is aangesloten. Hoe dat moet, volgt later.</p> <pre><code># MicroPython\nled.value(True); # Uitgang hoog of LED aan\n</code></pre> <p>We kunnen ook de LED uit zetten, zoals aangegeven in dit schema: </p> <p>Er kan nu geen stroom van + naar - lopen. In de code doen we dit zo:</p> <p><pre><code>// cpp\ndigitalWrite(3, false); // Pin 3 laag, LED uit\n</code></pre> In MicroPython gaat het zo: <pre><code># MicroPython\nled.value(False); # Uitgang laag of LED uit\n</code></pre></p> <p>In het bovenstaande voorbeeld gaat de LED aan als de uitgang hoog staat en uit als de uitgang laag staat. Dit noemen we een actief hoog signaal.</p> <p>Het is ook mogelijk om de LED (of iets anders zoals een motor, ... ) op een andere manier aan te sluiten zodat deze licht geeft (of actief is) wanneer de uitgang laag staat. Dit noemen we een actief laag signaal.</p> <p>Schema: </p> <p>Dit schema en de werking zijn nagenoeg hetzelfde, maar de LED en de serieweerstand zijn aan VCC aangesloten in plaats van aan GND. Dit wil zeggen dat de LED nu zal licht geven wanneer de uitgang van de microcontroller met GND verbonden is en zal uit zijn wanneer hij met VCC verbonden is.</p> <p>Nu moeten we in de code (C++ of MicroPython) de uitgang laag zetten om de LED te laten branden. Dit gebeurt met dezelfde code als hierboven om de uitgang laag te zetten: <pre><code>// cpp\ndigitalWrite(3, false); // Pin 3 laag, LED aan\n</code></pre> In MicroPython gaat het zo: <pre><code># MicroPython\nled.value(False); # Uitgang laag of LED aan\n</code></pre></p> <p>Om de LED uit te zetten, moeten we in dit geval de uitgang hoog (<code>true</code>) zetten:</p> <p>Schema: <pre><code>// cpp\ndigitalWrite(3, true); // Pin 3 hoog, LED uit\n</code></pre> In MicroPython gaat het zo: <pre><code># MicroPython\nled.value(True); # Uitgang hoog of LED uit\n</code></pre></p> <p>Een <code>1</code> of een <code>0</code>, <code>true</code> of <code>false</code>, <code>True</code> of <code>False</code> hebben in beide schema's dus een andere uitwerking. Het is belangrijk om hiermee rekening te houden!</p> <p>Let op!</p> <p>Bij Arduino kun je <code>HIGH</code> en <code>LOW</code> gebruiken als waarde voor digitale pinnen, bijvoorbeeld bij digitalWrite. Let op: dit zijn allemaal hoofdletters en werken alleen in de Arduino-omgeving. Voor gewone booleans in C++ gebruik je <code>true</code> en <code>false</code>. In andere C++-omgevingen werken <code>HIGH</code> en <code>LOW</code> meestal niet. In code ziet het er dan zo uit: </p> <p><pre><code>// cpp\ndigitalWrite(3, HIGH); // Pin 3 hoog, LED uit\n</code></pre> In MicroPython bestaan HIGH en LOW niet maar je kan in plaats van <code>False</code> of <code>True</code> ook <code>0</code> of <code>1</code> gebruiken:</p> <pre><code># MicroPython\nled.value(1); # Uitgang hoog of LED uit\n</code></pre>"},{"location":"toepassingen/","title":"Samenspel en toepassingen","text":""},{"location":"toepassingen/#input-output-combineren","title":"Input + Output combineren","text":"<p>Dimmen van een LED met een potmeter, of een knop die de toonhoogte van een buzzer verandert.</p>"},{"location":"toepassingen/#mini-verkeerslicht","title":"Mini verkeerslicht","text":"<pre><code>// Arduino (C++) voorbeeld\nint ledR = 10, ledG = 11, ledY = 12, button = 2;\nvoid setup() {\n  pinMode(ledR, OUTPUT);\n  pinMode(ledG, OUTPUT);\n  pinMode(ledY, OUTPUT);\n  pinMode(button, INPUT);\n}\nvoid loop() {\n  if (digitalRead(button) == HIGH) {\n    digitalWrite(ledR, HIGH);\n    delay(1000);\n    digitalWrite(ledR, LOW);\n    digitalWrite(ledG, HIGH);\n    delay(1000);\n    digitalWrite(ledG, LOW);\n    digitalWrite(ledY, HIGH);\n    delay(500);\n    digitalWrite(ledY, LOW);\n  }\n}\n</code></pre> <pre><code># MicroPython voorbeeld\nfrom machine import Pin\nimport time\nledR = Pin(15, Pin.OUT)\nledG = Pin(14, Pin.OUT)\nledY = Pin(13, Pin.OUT)\nbutton = Pin(12, Pin.IN)\nwhile True:\n    if button.value():\n        ledR.value(1)\n        time.sleep(1)\n        ledR.value(0)\n        ledG.value(1)\n        time.sleep(1)\n        ledG.value(0)\n        ledY.value(1)\n        time.sleep(0.5)\n        ledY.value(0)\n</code></pre> <p>Projectidee\u00ebn: - Reaction game met knop en LED - Toonhoogte veranderen met knop en buzzer</p>"},{"location":"vooruitblik/","title":"Vooruitblik","text":""},{"location":"vooruitblik/#andere-datatypes","title":"Andere datatypes","text":"<ul> <li>float (kommagetallen)</li> <li>string (tekst)</li> </ul>"},{"location":"vooruitblik/#serial-communicatie","title":"Serial communicatie","text":"<p>Met de computer praten via de seri\u00eble poort.</p> <pre><code>// Arduino (C++) voorbeeld\nSerial.println(\"Hallo!\");\n</code></pre> <pre><code># MicroPython voorbeeld\nprint(\"Hallo!\")\n</code></pre> <p>Later kun je uitbreiden met vb sensoren, displays en motoren!</p>"}]}